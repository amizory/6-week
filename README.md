# Основы Configuration Management/СУБД

* [Основные понятия CM](#Основные-понятия-CM)
* [Введение в Ansible](#Введение-в-Ansible)
* [Основные понятия СУБД](#Основные-понятия-СУБД)
* [Реляционные СУБД](#Реляционные-СУБД)
* [Администрирование СУБД](#Администрирование-СУБД)

## <a id="Основные-понятия-CM">Основные понятия CM</a>

```txt
1 - Что такое Configuration Management.
2 - Обзор и сравнение инструментов: Ansible, Chef, Puppet, SaltStack.
```

### Notice-1

```txt
1 - Что такое Configuration Management?

->  Configuration Management (CM) - это системный подход к управлению изменениями и
    конфигурациями программного обеспечения, аппаратного обеспечения, документации и других
    компонентов системы в течение всего жизненного цикла продукта. Он включает в себя
    идентификацию, документирование, версионирование, управление изменениями и отслеживание
    конфигураций для обеспечения целостности и согласованности системы.
    
    Например, в разработке программного обеспечения CM может включать в себя управление
    версиями кода, управление изменениями в базе данных, управление конфигурациями серверов
    и управление документацией. Это позволяет команде разработчиков отслеживать изменения,
    выявлять и исправлять ошибки, а также обеспечивать стабильность и безопасность системы.

    Например, если разработчик сделал изменения в коде, CM система может автоматически создать
    новую версию кода, обновить документацию и уведомить команду о изменениях. Это позволяет
    команде работать более эффективно и избегать ошибок, связанных с несоответствием
    конфигураций.
```

### Intern-1

```txt
1 - Какие есть примеры ПО, какие отличия между ними?

->  Есть много примеров ПО для Configuration Management.
    - Ansible: Ansible - это инструмент для автоматизации и управления конфигурациями. Он
    позволяет создавать и управлять конфигурациями серверов, приложений и сервисов.
    - Puppet: Puppet - это инструмент для управления конфигурациями и автоматизации. Он
    позволяет создавать и управлять конфигурациями серверов, приложений и сервисов.
    - Chef: Chef - это инструмент для управления конфигурациями и автоматизации. Он позволяет
    создавать и управлять конфигурациями серверов, приложений и сервисов.
    - SaltStack: SaltStack - это инструмент для управления конфигурациями и автоматизации. Он
    позволяет создавать и управлять конфигурациями серверов, приложений и сервисов.
    - Git: Git - это система управления версиями. Он позволяет управлять изменениями в коде
    и документации.

    Отличия между ними:
    - Ansible и Puppet более ориентированы на управление конфигурациями серверов и приложений,
    в то время как Chef и SaltStack более ориентированы на автоматизацию и управление
    конфигурациями.
    - Git более ориентирован на управление версиями кода и документации, в то время как другие
    инструменты более ориентированы на управление конфигурациями и автоматизацию.
    - Ansible и SaltStack используют агентless-архитектуру, что означает, что они не требую
    установки агента на управляемых узлах. Вместо этого, они используют существующие протоколы
    и инструменты, такие как SSH, WinRM и т. д., для управления конфигурациями. С другой
    стороны, Puppet и Chef используют агент-based-архитектуру, что означает, что они требуют
    установки агента на управляемых узлах. Этот агент периодически подключается к серверу
    управления и получает обновления конфигураций.
    - Ansible и Puppet имеют более простой синтаксис, в то время как Chef и SaltStack имеют
    более сложный синтаксис.
    В общем, выбор инструмента зависит от конкретных потребностей и требований проекта.
```

### Advanced-1

```txt
1 - Что такое push model в контексте Configuration Management?

->  В контексте Configuration Management, push model (модель пуша) - это подход, при котором
    сервер управления конфигурациями (CM-сервер) отправляет конфигурации и обновления на
    управляемые узлы (серверы, компьютеры и т. д.) по инициативе самого сервера.
    В этом подходе, CM-сервер периодически проверяет конфигурации управляемых узлов и, если
    обнаруживает несоответствия или необходимость обновления, отправляет обновленные
    конфигурации на эти узлы. Это означает, что управляемые узлы не запрашивают обновления
    конфигураций сами, а вместо этого получают их от CM-сервера.

    Примеры инструментов, которые используют push model, включают Ansible и SaltStack.

    Преимущества push model:
    - Упрощенная конфигурация и управление
    - Более быстрая доставка обновлений конфигураций
    - Улучшенная безопасность, поскольку управляемые узлы не должны запрашивать обновления
    конфигураций

    Недостатки push model:
    - Требуется более высокий уровень доступа к управляемым узлам
    - Может быть более сложно управлять конфигурациями в больших и распределенных средах.
```

```txt
2 - Что такое pull model в контексте Configuration Management?

->  В контексте Configuration Management, pull model (модель пулла) - это подход, при
    котором управляемые узлы (серверы, компьютеры и т. д.) периодически запрашивают обновления
    конфигураций у сервера управления конфигурациями (CM-сервера).
    В этом подходе, управляемые узлы устанавливают соединение с CM-сервером и запрашивают
    обновления конфигураций. CM-сервер проверяет, есть ли обновления конфигураций для данного
    узла, и, если да, отправляет их на узел. Узел затем применяет обновления конфигураций.

    Примеры инструментов, которые используют pull model, включают Puppet и Chef.

    Преимущества pull model:
    - Управляемые узлы могут быть более автономными и не требуют постоянного подключения
    к CM-серверу
    - Более простая конфигурация и управление в больших и распределенных средах
    - Улучшенная безопасность, поскольку управляемые узлы не должны получать обновления
    конфигураций от CM-сервера без запроса

    Недостатки pull model:
    - Требуется более высокий уровень сложности конфигурации и управления
    - Может быть более медленная доставка обновлений конфигураций, поскольку управляемые узлы
    должны периодически запрашивать обновления.
    
    В целом, pull model более подходит для больших и распределенных сред, где управляемые
    узлы могут быть автономными и не требуют постоянного подключения к CM-серверу.
```

## <a id="Введение-в-Ansible">Введение в Ansible</a>

```txt
1 - Установка Ansible.
2 - Файлы конфигурации (ansible.cfg).
3 - Ansible Inventory file.
4 - Основные модули.
5 - Ansible-playbook.
6 - Ansible Facts
7 - Handlers.
8 - Роли.
9 - ansible-galaxy.
10 - Ansible Best Practice
```

### Notice-2

```txt
1 - Каким требованиям должен соответствовать хост для установки Ansible?

->  Хост для установки Ansible должен соответствовать следующим требованиям:
    - Операционная система: Linux, macOS или Windows (с помощью Cygwin или WSL)
    - Python 3.6 или новее (для Ansible 2.9 и выше)
    - Память: минимум 512 МБ, но рекомендуется 2 ГБ или более для больших инфраструктур
    - Доступ к сети для подключения к управляемым узлам
    - Установленный пакетный менеджер (например, pip для Python)
    - Права администратора для установки и запуска Ansible
    - Поддержка SSH (для подключения к управляемым узлам по протоколу SSH)
    - Рекомендуется использовать 64-разрядную операционную систему для большей
    производительности
    - Доступ к репозиториям Ansible (например, Ansible Galaxy) для установки ролей и коллекций
    - Поддержка SSL/TLS для безопасного подключения к управляемым узлам
    - Рекомендуется использовать отдельный пользователь для запуска Ansible, а не использовать
    учетную запись root
    - Возможность установки дополнительных пакетов и зависимостей, необходимых для работы
    Ansible (например, Jinja2, PyYAML)
```

```txt
2 - Какими хостами можно управлять с помощью Ansible?

->  Linux: различные дистрибутивы, такие как Ubuntu, CentOS, Red Hat Enterprise, Debian и другие
    Windows: с помощью модуля winrm или psrp
    macOS/FreeBSD/ OpenBSD/ NetBSD/ Solaris/ AIX/HP-UX - : с помощью модуля ssh 

    - Сетевыми устройствами: маршрутизаторами, коммутаторами, файрволами и другими устройствами
    от производителей таких как Cisco, Juniper, Arista и другие
    - Хранилищами: NAS, SAN, объектными хранилищами и другими типами хранилищ
    - Виртуальными машинами: VMware, VirtualBox, KVM, Xen и другие
    - Контейнерами: Docker, Kubernetes, OpenShift и другие

    Ansible также поддерживает управление облачными сервисами, такими как:
    - Amazon Web Services (AWS)
    - Microsoft Azure
    - Google Cloud Platform (GCP)
    - OpenStack
    - VMware vCloud

    Ansible также поддерживает управление различными приложениями и сервисами, такими как:
    - Базы данных: MySQL, PostgreSQL, Oracle, Microsoft SQL Server
    - Веб-серверы: Apache, Nginx, IIS
    - Приложения: Tomcat, JBoss, WebSphere
    - Сервисы: DNS, DHCP, NTP
```

```txt
3 - Для чего нужен файл .ansible.cfg ?

->  Файл .ansible.cfg является конфигурационным файлом Ansible, который позволяет настроить
    поведение Ansible на уровне проекта или системы. В этом файле можно указать различные
    параметры, которые будут применены ко всем playbook и ролям, используемым в проекте.

    Некоторые из возможностей, которые можно настроить в файле .ansible.cfg:
    - Путь к файлам inventory (спискам хостов)
    - Путь к файлам playbook и ролям
    - Настройки подключения к хостам (например, SSH-параметры)
    - Настройки логирования и отчетности
    - Настройки безопасности (например, использование SSL/TLS)
    - Настройки работы с модулями и плагинами

    [defaults]
    inventory = ./hosts
    remote_user = ansible
    become = yes
    become_method = sudo

    [ssh_connection]
    ssh_args = -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no

    [log]
    log_file = ./ansible.log
    log_level = DEBUG
    
    В этом примере файл .ansible.cfg настраивает:
    - Путь к файлу inventory (./hosts)
    - Пользователя, под которым будет выполняться Ansible (ansible)
    - Использование sudo для повышения привилегий
    - Параметры подключения по SSH (отключение проверки известных хостов и строгой проверки
    ключей)
    - Логирование в файл (./ansible.log) с уровнем логирования DEBUG

    Файл .ansible.cfg можно разместить в корне проекта или в домашней директории пользователя,
    и Ansible будет использовать его для настройки своего поведения.
```

```txt
4 - Что такое inventory file? В каких форматах может быть написан?

->  Inventory file (файл инвентаря) - это файл, который содержит список хостов, которые будут
    управляться Ansible. В этом файле перечисляются хосты, которые будут использоваться в
    playbook, а также могут быть указаны дополнительные параметры, такие как группы хостов,
    переменные и т. д.

    Inventory file может быть написан в следующих форматах:
    ---
    INI-файл: Это традиционный формат файла инвентаря Ansible. В этом формате хосты
    перечисляются в виде секций, каждая из которых начинается с ключевого слова [group_name].
    [web_servers]
    server1 ansible_host=192.168.1.100
    server2 ansible_host=192.168.1.101

    [db_servers]
    db1 ansible_host=192.168.1.200
    db2 ansible_host=192.168.1.201
    ---
    YAML-файл: Этот формат файла инвентаря стал более популярным в последнее время. В этом
    формате хосты перечисляются в виде списка, каждый элемент которого представляет собой
    словарь с ключами name и ansible_host.
    
    all:
        children:
            web_servers:
                hosts:
                    server1:
                        ansible_host: 192.168.1.100
                    server2:
                        ansible_host: 192.168.1.101
                db_servers:
                    hosts:
                        db1:
                            ansible_host: 192.168.1.200
                        db2:
                            ansible_host: 192.168.1.201
    ---
    JSON-файл: Этот формат файла инвентаря также поддерживается Ansible. В этом формате хосты
    перечисляются в виде списка, каждый элемент которого представляет собой объект с ключами
    name и ansible_host.
{
    "all": {
        "children": {
            "web_servers": {
                "hosts": {
                    "server1": {
                        "ansible_host": "192.168.1.100"
                    },
                    "server2": {
                        "ansible_host": "192.168.1.101"
                    }
                }
            },
            "db_servers": {
                "hosts": {
                    "db1": {
                        "ansible_host": "192.168.1.200"
                    },
                    "db2": {
                        "ansible_host": "192.168.1.201"
                    }
                }
            }
        }
        }
}

    Динамический инвентарь: Ansible также поддерживает динамический инвентарь, который
    позволяет автоматически обнаруживать хосты в различных источниках, таких как AWS, Azure,
    Google Cloud и т. д.
```

```txt
5 - В чем отличие между модулем и плагином в Ansible?

->  В Ansible модули и плагины являются двумя разными типами компонентов, которые выполняют
    различные функции.
    
    Модули в Ansible - это небольшие программы, которые выполняют конкретные задачи, такие как:
    - Управление файлами и директориями
    - Управление пакетами и репозиториями
    - Управление сетью и безопасностью
    - Управление базами данных и т. д.
    Модули являются основными строительными блоками Ansible и используются для выполнения
    задач в playbook. Они могут быть написаны на любом языке программирования, поддерживаемом
    Ansible, таком как Python, Ruby, Perl и т. д.
    Примеры модулей Ansible:
    - file: управляет файлами и директориями
    - package: управляет пакетами и репозиториями
    - user: управляет пользователями и группами
    - service: управляет сервисами и демонами


    Плагины в Ansible - это компоненты, которые расширяют функциональность Ansible, добавляя
    новые возможности и функции. Плагины могут быть использованы для:
    - Улучшения производительности и эффективности Ansible
    - Добавления поддержки новых операционных систем и платформ
    - Расширения функциональности модулей и playbook
    - Интеграции Ansible с другими инструментами и системами
    Плагины могут быть написаны на любом языке программирования, поддерживаемом Ansible, и
    могут быть загружены в Ansible как отдельные модули.
    - Примеры плагинов Ansible:
    - ansible-galaxy: плагин для управления ролями и коллекциями Ansible
    - ansible-lint: плагин для проверки синтаксиса и стилей playbook
    - ansible-vault: плагин для шифрования и дешифрования данных в Ansible

    Основные отличия между модулями и плагинами Ansible:
    - Модули выполняют конкретные задачи, в то время как плагины расширяют функциональность
    Ansible.
    - Модули являются основными строительными блоками Ansible, в то время как плагины являются
    дополнительными компонентами.
    - Модули обычно пишутся на Python, в то время как плагины могут быть написаны на любом
    языке программирования, поддерживаемом Ansible.
```

```txt
6 - Что такое Ansible-playbook? Что такое Ansible-play и Ansible-task?

->  Ansible-playbook - это файл, который содержит описание набора задач, которые необходимо
    выполнить на группе хостов. Playbook - это основной компонент Ansible, который позволяет
    автоматизировать выполнение задач на нескольких хостах.
    Playbook состоит из одной или нескольких play, каждая из которых представляет собой набор
    задач, которые необходимо выполнить на группе хостов.

    Ansible-play - это набор задач, которые необходимо выполнить на группе хостов.
    Play - это основная единица работы в Ansible, которая позволяет выполнить набор задач
    на группе хостов.
    Play состоит из следующих компонентов:
    - hosts: список хостов, на которых необходимо выполнить задачи
    - tasks: список задач, которые необходимо выполнить на хостах
    - handlers: список обработчиков, которые необходимо выполнить на хостах

    Ansible-task - это отдельная задача, которая необходимо выполнить на группе хостов.
    Task - это основная единица работы в Ansible, которая позволяет выполнить одну задачу
    на группе хостов.
    Task состоит из следующих компонентов:
    - module: модуль Ansible, который необходимо использовать для выполнения задачи
    - args: аргументы, которые необходимо передать модулю
    - when: условие, при котором необходимо выполнить задачу

    ---
      - name: Установка и настройка веб-сервера
        hosts: web_servers
        become: yes

        tasks:
      - name: Установка пакета httpd
            yum:
                name: httpd
                state: present

      - name: Настройка файла конфигурации httpd
        template:
            src: templates/httpd.conf.j2
            dest: /etc/httpd/conf/httpd.conf
            mode: '0644'
    
    В этом примере playbook состоит из одной play, которая выполняет две задачи на
    группе хостов web_servers. Первая задача устанавливает пакет httpd, а вторая задача
    настраивает файл конфигурации httpd.
```

```txt
7 - Что такое Ansible-роль?

->  Ansible-роль - это набор задач, переменных и шаблонов, которые можно использовать
    для автоматизации выполнения задач на группе хостов. Роли позволяют упростить процесс
    управления конфигурацией и развертывания приложений на нескольких хостах.
    Роль состоит из следующих компонентов:
    - tasks: список задач, которые необходимо выполнить на хостах
    - handlers: список обработчиков, которые необходимо выполнить на хостах
    - vars: список переменных, которые можно использовать в задачах и обработчиках
    - templates: список шаблонов, которые можно использовать для генерации файлов конфигурации
    - files: список файлов, которые можно использовать для копирования на хосты
    - meta: мета-данные о роли, такие как описание, версия и автор

    Роли можно использовать для:
    - Установки и настройки приложений
    - Конфигурации сетевых устройств
    - Установки и настройки баз данных
    - Установки и настройки веб-серверов

    Роли можно создавать самостоятельно или использовать готовые роли из
    репозитория Ansible Galaxy.

    Например, роль для установки и настройки веб-сервера Apache может состоять
    из следующих компонентов:

    tasks:
    Установка пакета Apache
    Настройка файла конфигурации Apache
    Запуск сервиса Apache
    handlers:
    Перезапуск сервиса Apache при изменении файла конфигурации
    vars:
    Переменная apache_port для указания порта, на котором будет работать Apache
    templates:
    Шаблон файла конфигурации Apache
    files:
    Файл индексной страницы Apache
    meta:
    Описание роли
    Версия роли
    Автор роли

    Чтобы использовать роль, необходимо создать playbook, который будет вызывать роль.
    ---
    - name: Установка и настройка веб-сервера Apache
      hosts: web_servers
      become: yes

      roles:
      - apache
    В этом примере playbook вызывает роль apache, которая устанавливает и
    настраивает веб-сервер Apache на группе хостов web_servers.
```

```txt
8 - Как задать имя пользователя, от имени которого Ansible будет подключаться к целевому хосту?

->  В Ansible можно задать имя пользователя, от имени которого Ansible будет подключаться к
    целевому хосту, используя директиву remote_user в playbook или в файле инвентаря.
    ---
    - name: Установка и настройка веб-сервера Apache
      hosts: web_servers
      become: yes
      remote_user: username
    В этом примере playbook задает имя пользователя username, от имени которого Ansible
    будет подключаться к целевому хосту.
    ---
    [web_servers]
    server1 ansible_host=192.168.1.100 remote_user=username
    server2 ansible_host=192.168.1.101 remote_user=username
    В этом примере файле инвентаря задает имя пользователя username, от имени которого
    Ansible будет подключаться к целевому хосту server1 и server2.
    ---
    - name: Установка и настройка веб-сервера Apache
      hosts: web_servers
      become: yes
      vars:
        remote_user: username
    В этом примере playbook задает переменную remote_user с значением username, от
    имени которого Ansible будет подключаться к целевому хосту.
    ---
    [defaults]
    remote_user = username
    В этом примере файле конфигурации Ansible задает значение remote_user с значением
    username, от имени которого Ansible будет подключаться к целевому хосту по умолчанию.
```

```txt
9 - Как задать путь к ssh ключу для подключения к целевому хосту?

->  В Ansible можно задать путь к ssh ключу для подключения к целевому хосту,
    используя директиву private_key_file в playbook или в файле инвентаря.

    - name: Установка и настройка веб-сервера Apache
      hosts: web_servers
      become: yes
      private_key_file: /path/to/ssh/key
    В этом примере playbook задает путь к ssh ключу /path/to/ssh/key, который будет
    использоваться для подключения к целевому хосту.
  ---
    [web_servers]
    server1 ansible_host=192.168.1.100 private_key_file=/path/to/ssh/key
    server2 ansible_host=192.168.1.101 private_key_file=/path/to/ssh/key
    В этом примере файле инвентаря задает путь к ssh ключу /path/to/ssh/key, который будет
    использоваться для подключения к целевому хосту server1 и server2.
  ---
    - name: Установка и настройка веб-сервера Apache
    hosts: web_servers
    become: yes
    vars:
      private_key_file: /path/to/ssh/key
    В этом примере playbook задает переменную private_key_file с значением /path/to/ssh/key,
    который будет использоваться для подключения к целевому хосту.
  ---
    [defaults]
    private_key_file = /path/to/ssh/key
    В этом примере файле конфигурации Ansible задает значение private_key_file с
    значением /path/to/ssh/key, который будет использоваться для подключения к целевому
    хосту по умолчанию.

    "ansible_ssh_private_key_file вместо private_key_file"
```

```txt
10 - Как скопировать файл на целевой хост с помощью Ansible?

-> --------------------------------------------------------
- name: Копирование файла на целевой хост
  hosts: web_servers
  become: yes

  tasks:
  - name: Копирование файла
    copy:
      content: "Hello, World!"
      dest: /path/to/file.txt
  В этом примере playbook копирует файл file.txt с содержимым "Hello, World!" в директорию
  /path/to/ на целевом хосте.
  --------------------------------------------------------
- name: Копирование файла на целевой хост
  hosts: web_servers
  become: yes

  tasks:
  - name: Копирование файла
    copy:
      src: /path/to/local/file.txt
      dest: /path/to/remote/file.txt
  В этом примере playbook копирует файл file.txt из локальной директории /path/to/local/ в
  директорию /path/to/remote/ на целевом хосте.
  --------------------------------------------------------
- name: Копирование файла на целевой хост
  hosts: web_servers
  become: yes

  tasks:
  - name: Копирование файла
    template:
      src: templates/file.txt.j2
      dest: /path/to/file.txt
  В этом примере playbook копирует файл file.txt из шаблона file.txt.j2 в директорию
  /path/to/ на целевом хосте.

    Параметры модуля copy
    - content: содержимое файла, которое будет скопировано
    - dest: путь к файлу, который будет скопирован
    - src: путь к локальному файлу, который будет скопирован
    - mode: права доступа к файлу, которые будут установлены после копирования
    - owner: владелец файла, который будет установлен после копирования
    - group: группа файла, которая будет установлена после копирования
  Модуль copy также поддерживает другие параметры, такие как backup, force, follow,
  local_follow и другие.
```

```txt
11 - Как создать нового пользователя в Linux с помощью Ansible?

->  В Ansible, вы можете создать нового пользователя в Linux с помощью модуля user.
  - name: Создание нового пользователя
    hosts: web_servers
    become: yes

    tasks:
    - name: Создание пользователя
      user:
        name: "новый_пользователь"
        comment: "Новый пользователь"
        shell: "/bin/bash"
        home: "/home/новый_пользователь"
        createhome: yes
        system: no
        groups: "wheel"
    
    В этом примере playbook создает нового пользователя с именем "новый_пользователь",
    комментарием "Новый пользователь", shell "/bin/bash", домашней директорией
    "/home/новый_пользователь" и добавляет его в группу "wheel".
    Параметры модуля user
    - name: имя пользователя
    - comment: комментарий к пользователю
    - shell: shell пользователя
    - home: домашняя директория пользователя
    - createhome: создать домашнюю директорию пользователя (yes/no)
    - system: является ли пользователь системным (yes/no)
    - groups: группы, в которые добавляется пользователь

    Переменные
    groups: "{{ groups }}"

    ----------------------------------
  - name: Создание нового пользователя
    hosts: web_servers
    become: yes

    tasks:
    - name: Создание пользователя
      template:
        src: templates/user.j2
        dest: /etc/passwd
        mode: '0644'
    
    Шаблон
    {{ username }}:x:{{ uid }}:{{ gid }}:{{ comment }}:{{ home }}:{{ shell }}
```

```txt
12 - Зачем используется модуль template в Ansible?

->  Модуль template в Ansible используется для создания файлов на основе шаблонов.
    Шаблоны могут содержать переменные, которые заменяются на фактические значения во
    время выполнения playbook.

    - Создание файлов конфигурации на основе шаблонов
    - Создание файлов с переменными, которые заменяются на фактические значения
    - Создание файлов с динамическим содержимым

    ---
    - name: Создание файла конфигурации
      hosts: web_servers
      become: yes

      tasks:
      - name: Создание файла конфигурации
        template:
          src: templates/config.j2
          dest: /etc/config
          mode: '0644'
    В этом примере playbook создает файл конфигурации на основе шаблона config.j2 и
    сохраняет его в файл /etc/config.

    server {
      listen {{ port }};
      server_name {{ server_name }};
      root {{ root }};
    }
    В этом примере шаблона создается файл конфигурации с переменными port,
    server_name и root, которые заменяются на фактические значения во время выполнения
    playbook.
    Модуль template имеет следующие преимущества:
    - Упрощает создание файлов конфигурации
    - Позволяет использовать переменные в файлах конфигурации
    - Позволяет создавать файлы с динамическим содержимым
```

```txt
13 - Как выполнять задачи из плейбука от привилегированного пользователя?

->  
```

### Intern-2

```txt
1 - Какие есть способы эскалации привилегий в Ansible (become methods)?

->
```

```txt
2 - Что такое handler и зачем он нужен? Как использовать handler?

->
```

```txt
3 - Что происходит на этапе Gathering Facts при выполнении плейбука?

->
```

```txt
4 - Как можно узнать имя и версию дистрибутива Linux, на котором в данных момент выполнятся плейбук?

->
```

```txt
5 - Можно ли пропустить этап Gathering Facts ?

->  
```

```txt
6 - Как найти и заменить строку в заданном файле с помощью регулярного выражения?

->  
```

```txt
7 - Как зарегистрировать переменную в плейбуке в runtime?

->  
```

```txt
8 - Что такое Ansible-galaxy?

->  
```

```txt
9 - Как установить дополнительный модуль/плагин из Ansible-galaxy?

->  
```

### Advanced-2

```txt
1 - Как c помощью Ansible найти все файлы в заданной директории, которые оканчиваются
    на .log и записать их полные пути в переменную в плейбуке ?

->
```

```txt
2 - Что можно сделать с помощью плагина lookup?

->
```

```txt
3 - Как можно ускорить выполнение плейбука запущенного на большом количестве хостов?
->
```

## <a id="Основные-понятия-СУБД">Основные понятия СУБД</a>

```txt
1 - Реляционные СУБД.
2 - Нереляционные СУБД.
3 - Типы нереляционных СУБД
```

### Notice-3

```txt
1 - Что такое реляционные СУБД? Как они устроены? Примеры, отличия.

->  Реляционные СУБД (Relational Database Management System, RDBMS) - это системы управления
    базами данных, в которых данные хранятся в виде таблиц, связанных между собой отношениями.
    
    Устройство:
    - Таблицы (relations) состоят из строк (records) и столбцов (fields)
    - Каждая строка представляет собой запись, а столбцы - атрибуты записи
    - Отношения между таблицами устанавливаются с помощью ключей (primary key, foreign key)
    - Ключи обеспечивают уникальность и целостность данных
    - Таблицы могут быть связаны между собой с помощью различных типов отношений:
      один-к-одному, один-ко-многим, многие-ко-многим
    
    Примеры:
    - MySQL - одна из самых популярных реляционных СУБД, известная своей простотой и гибкостью
    - PostgreSQL - мощная и функциональная реляционная СУБД, известная своей способностью
    обрабатывать большие объемы данных
    - Microsoft SQL Server - коммерческая реляционная СУБД, разработанная компанией Microsoft,
    известная своей интеграцией с другими продуктами Microsoft
    - Oracle - коммерческая реляционная СУБД, известная своей высокой производительностью 
     функциональностью
    
    Отличия:
    - Лицензия: MySQL и PostgreSQL являются открытыми и бесплатными, в то время как Microsoft
    SQL Server и Oracle являются коммерческими продуктами, требующими лицензионных платежей.
    - Производительность: Oracle и Microsoft SQL Server известны своей высокой
    производительностью и способностью обрабатывать большие объемы данных, в то время как MySQL
    и PostgreSQL могут быть менее производительными, но более гибкими.
    - Функциональность: PostgreSQL и Oracle имеют более широкий спектр функциональных
    возможностей, включая поддержку оконных функций, Common Table Expressions (CTE) и других
    продвинутых функций, в то время как MySQL и Microsoft SQL Server имеют более ограниченный
    набор функций.
    - Управление данными: Oracle и Microsoft SQL Server имеют более сложные системы управления
    данными, включая поддержку параллельных транзакций и распределенных баз данных, в то время
    как MySQL и PostgreSQL имеют более простые системы управления данными.
    - Интеграция: Microsoft SQL Server имеет тесную интеграцию с другими продуктами Microsoft,
    такими как Visual Studio и SharePoint, в то время как Oracle имеет интеграцию с другими
    продуктами Oracle, такими как Java и WebLogic.
    - Поддержка: Oracle и Microsoft SQL Server имеют более широкую поддержку и более крупные
    сообщества пользователей, в то время как MySQL и PostgreSQL имеют более ограниченную
    поддержку и меньшие сообщества пользователей.
```

```txt
2 - Что такое нереляционные СУБД?

->  Нереляционные СУБД (NoSQL Database Management System) - это системы управления базами
    данных, которые не используют традиционную реляционную модель данных, основанную на
    таблицах и отношениях.

    Характеристики нереляционных СУБД:
    - Нет таблиц и отношений: данные хранятся в виде документов, ключ-значение или других
    структур данных.
    - Нет схемы: нет заранее определенной структуры данных, данные могут быть добавлены или
    изменены динамически.
    - Гибкая структура данных: данные могут быть представлены в различных форматах.
    - Масштабируемость: нереляционные СУБД могут быть легко масштабированы для обработки
    больших объемов данных.
    - Высокая производительность: нереляционные СУБД могут обеспечивать высокую
    производительность, поскольку они не требуют выполнения сложных запросов и транзакций.

    Преимущества нереляционных СУБД:
    - Гибкость: нереляционные СУБД могут быть легко адаптированы к меняющимся требованиям
    приложения.
    - Масштабируемость: нереляционные СУБД могут быть легко масштабированы для обработки
    больших объемов данных.
    - Высокая производительность: нереляционные СУБД могут обеспечивать высокую
    производительность, поскольку они не требуют выполнения сложных запросов и транзакций.

    Недостатки нереляционных СУБД:
    - Отсутствие стандартизации: нереляционные СУБД имеют разные модели данных и языки
    запросов.
    - Отсутствие поддержки транзакций: нереляционные СУБД могут не поддерживать транзакции,
    что может привести к проблемам с целостностью данных.
    - Отсутствие поддержки сложных запросов: нереляционные СУБД могут не поддерживать сложные
    запросы, что может привести к проблемам с анализом данных.
```

### Intern-3

```txt
1 - Какие есть типы нереляционных СУБД?

->  - Документо-ориентированные СУБД: в этих СУБД данные хранятся в виде документов, которые
    могут быть представлены в различных форматах, таких как JSON, XML или CSV. Документы
    могут содержать различные типы данных, такие как текст, числа, даты и т. д. Примеры:
    MongoDB, Couchbase, RavenDB.

    - Ключ-значение СУБД: в этих СУБД данные хранятся в виде пар ключ-значение, где ключ
    используется для доступа к значению. Ключ-значение СУБД часто используются для хранения
    данных, которые требуют быстрого доступа и обновления. Примеры: Redis, Riak, Amazon
    DynamoDB.

    - Графовые СУБД: в этих СУБД данные хранятся в виде графа, где каждый узел представляет
    собой отдельный объект, а ребра представляют собой связи между объектами. Графовые СУБД
    часто используются для хранения данных, которые имеют сложные связи и отношения.
    Примеры: Neo4j, Amazon Neptune, OrientDB.

    - Колонно-ориентированные СУБД: в этих СУБД данные хранятся в виде столбцов, где каждый
    столбец представляет собой отдельный атрибут данных. Колонно-ориентированные СУБД часто
    используются для хранения данных, которые требуют быстрого доступа и анализа.
    Примеры: Cassandra, HBase, Amazon Redshift.

    - Объектно-ориентированные СУБД: в этих СУБД данные хранятся в виде объектов, которые
    могут быть представлены в различных форматах, таких как JSON или XML.
    Объектно-ориентированные СУБД часто используются для хранения данных, которые имеют
    сложную структуру и отношения. Примеры: ObjectDB, Matisse, Gemstone.

    - Мультимодельные СУБД: в этих СУБД данные могут быть представлены в различных форматах,
    таких как документы, ключ-значение, графы или столбцы. Мультимодельные СУБД часто
    используются для хранения данных, которые имеют сложную структуру и отношения.
    Примеры: OrientDB, ArangoDB, Cosmos DB.

    - Тайм-серийные СУБД: в этих СУБД данные хранятся в виде временных рядов, где каждый
    ряд представляет собой последовательность данных, отсортированных по времени.
    Тайм-серийные СУБД часто используются для хранения данных, которые имеют временную
    зависимость. Примеры: InfluxDB, OpenTSDB, TimescaleDB.

    - Сетевые СУБД: в этих СУБД данные хранятся в виде сетей, где каждый узел представляет
    собой отдельный объект, а ребра представляют собой связи между объектами. Сетевые СУБД
    часто используются для хранения данных, которые имеют сложные связи и отношения.
    Примеры: Amazon Neptune, OrientDB, TigerGraph.
```

```txt
2 - Чем они отличаются друг от друга?

->  1 - Модель данных: каждая нереляционная СУБД имеет свою собственную модель данных, которая
    определяет, как данные хранятся и взаимодействуют друг с другом. Например,
    документо-ориентированные СУБД хранят данные в виде документов, ключ-значение СУБД хранят
    данные в виде пар ключ-значение, а графовые СУБД хранят данные в виде графа.

    2 - Язык запросов: каждая нереляционная СУБД имеет свой собственный язык запросов, который
    используется для доступа и манипулирования данными. Например, MongoDB использует язык
    запросов MongoDB, а Cassandra использует язык запросов CQL.

    3 - Производительность: нереляционные СУБД могут иметь разную производительность, в
    зависимости от их архитектуры и реализации. Например, некоторые СУБД, такие как Redis,
    оптимизированы для высоких скоростей чтения и записи, в то время как другие, такие как
    MongoDB, оптимизированы для сложных запросов и анализа данных.

    4 - Масштабируемость: нереляционные СУБД могут иметь разную масштабируемость, в зависимости
    от их архитектуры и реализации. Например, некоторые СУБД, такие как Cassandra, могут быть
    легко масштабированы для обработки больших объемов данных, в то время как другие, такие как
    MongoDB, могут иметь более сложную масштабируемость.

    5 - Транзакционность: нереляционные СУБД могут иметь разную транзакционность, в зависимости
    от их архитектуры и реализации. Например, некоторые СУБД, такие как MongoDB, поддерживают
    транзакции, в то время как другие, такие как Redis, не поддерживают транзакции.

    6 - Безопасность: нереляционные СУБД могут иметь разную безопасность, в зависимости от
    их архитектуры и реализации. Например, некоторые СУБД, такие как MongoDB, имеют
    встроенную поддержку шифрования и аутентификации, в то время как другие, такие как Redis,
    могут иметь более ограниченную безопасность.

    7 - Сообщество и поддержка: нереляционные СУБД могут иметь разное сообщество и поддержку,
    в зависимости от их популярности и использования. Например, некоторые СУБД, такие как
    MongoDB, имеют большое и активное сообщество, в то время как другие, такие как Redis,
    могут иметь более ограниченное сообщество.
```

### Advanced-3

```txt
1 - Для решения каких задач может пригодится Redis?

->  Redis может пригодиться для решения следующих задач:
    - Кэширование данных: хранение часто запрашиваемых данных в оперативной
    памяти для ускорения доступа к ним. Например, кэширование результатов сложных
    запросов к базе данных или хранение часто используемых данных в приложении.
    - Хранение сессий: хранение данных о сессиях пользователей в приложении, таких как
    авторизационные данные, данные о корзине и т.п.
    - Обработка сообщений в реальном времени: обмен сообщениями между приложениями или
    сервисами в режиме реального времени. Например, отправка уведомлений о новых сообщениях
    в чате или обновление данных на сайте в режиме реального времени.
    - Хранение данных в формате ключ-значение: хранение данных в формате ключ-значение,
    что позволяет быстро искать и обновлять данные по ключу. Например, хранение настроек
    приложения или данных о пользователях.
    - Реализация очередей и публикации/подписки на сообщения: создание очередей для
    обработки задач в фоновом режиме или реализация механизма публикации/подписки на
    сообщения для обмена данными между приложениями.

    Примеры использования Redis:
    - В социальной сети для хранения данных о друзьях и подписках пользователей.
    - В онлайн-магазине для хранения данных о корзине и заказах пользователей.
    - В чате для хранения данных о сообщениях и обновлениях в режиме реального времени.
    - В приложении для хранения настроек и данных о пользователях.
```

```txt
2 - Для решения каких задач может пригодится MongoDB?

->  MongoDB может пригодиться для решения следующих задач:
    - Хранение больших объемов данных: MongoDB позволяет хранить большие объемы данных,
    включая структурированные, полуструктурированные и неструктурированные данные.
    - Работа с документо-ориентированными данными: MongoDB позволяет хранить данные в виде
    документов, что позволяет легко хранить и обрабатывать сложные данные.
    - Гибкая схема данных: MongoDB позволяет легко изменять схему данных, что позволяет быстро
    адаптироваться к меняющимся требованиям приложения.
    - Масштабируемость: MongoDB позволяет легко масштабировать базу данных, добавляя новые
    серверы и реплики, что позволяет обеспечить высокую доступность и производительность.
    - Анализ больших данных: MongoDB позволяет легко анализировать большие объемы данных,
    используя такие инструменты, как MapReduce и агрегатные функции.
    - Реализация микросервисной архитектуры: MongoDB позволяет легко реализовать микросервисную
    архитектуру, храня данные в отдельных базах данных для каждого микросервиса.

    Примеры использования MongoDB:
    - В социальной сети для хранения данных о пользователях, друзьях и подписках.
    - В онлайн-магазине для хранения данных о продуктах, заказах и клиентах.
    - В приложении для хранения данных о пользователях, настройках и истории действий.
    - В системе управления контентом для хранения данных о статьях, комментариях и
    пользователях.
    - В системе анализа данных для хранения и анализа больших объемов данных.

    MongoDB особенно подходит для приложений, которые требуют:
    - Гибкой схемы данных
    - Высокой масштабируемости
    - Высокой производительности
    - Легкой интеграции с другими сервисами и приложениями.
```

```txt
3 - Для решения каких задач может пригодится Elasticsearch?

->  Elasticsearch может пригодиться для решения следующих задач:
    - Поиск и фильтрация данных: Elasticsearch позволяет быстро искать и фильтровать большие
    объемы данных, используя различные типы запросов, включая полнотекстовый поиск, поиск п
     фразам и поиск по полям.
    - Анализ и обработка данных: Elasticsearch позволяет анализировать и обрабатывать данные,
    используя такие инструменты, как агрегации, фильтры и скрипты.
    - Хранение и поиск логов: Elasticsearch часто используется для хранения и поиска логов,
    что позволяет быстро находить и анализировать данные о работе приложения или системы.
    - Мониторинг и анализ производительности: Elasticsearch позволяет мониторить и
    анализировать производительность приложения или системы, используя такие инструменты
     как Kibana и X-Pack.
    - Реализация поисковых систем: Elasticsearch может быть использован для реализации
    поисковых систем, которые позволяют пользователям быстро находить необходимую информацию.
    - Анализ и визуализация данных: Elasticsearch позволяет анализировать и визуализировать
    данные, используя такие инструменты, как Kibana и Grafana.

    Примеры использования Elasticsearch:
    - В веб-приложении для реализации поиска по содержимому страниц.
    - В системе управления контентом для поиска и фильтрации статей и комментариев.
    - В системе мониторинга для хранения и анализа логов и данных о производительности.
    - В системе анализа данных для анализа и визуализации больших объемов данных.
    - В системе безопасности для хранения и анализа логов и данных о безопасности.

    Elasticsearch особенно подходит для приложений, которые требуют:
    - Быстрого поиска и фильтрации данных
    - Анализа и обработки больших объемов данных
    - Хранения и поиска логов и данных о производительности
    - Реализации поисковых систем
    - Анализа и визуализации данных.
```

```txt
4 - Что такое Open Search? Чем он отличается от Elasticsearch?

->  OpenSearch - это открытая, бесплатная и community-driven поисковая и аналитическая
    платформа, которая была создана на основе кодовой базы Elasticsearch. OpenSearch был
    создан Amazon Web Services (AWS) в 2021 году, после того как Elastic, компания, стоящая за
    Elasticsearch, изменила лицензию на свой продукт, сделав его менее открытой и более
    коммерческой.

    OpenSearch отличается от Elasticsearch следующими способами:
    - Лицензия: OpenSearch выпущен под лицензией Apache 2.0, которая является более открытой
    и менее ограничительной, чем лицензия Elastic, которая используется в Elasticsearch.
    - Сообщество: OpenSearch имеет более открытое и community-driven подход к разработке и
    поддержке, в отличие от Elasticsearch, который больше контролируется Elastic.
    - Функциональность: OpenSearch имеет большинство функций Elasticsearch, но также имеет
    некоторые дополнительные функции, такие как поддержка более широкого спектра форматов
    данных и улучшенная производительность.
    - Совместимость: OpenSearch совместим с большинством инструментов и приложений, которые
    работают с Elasticsearch, но также имеет некоторые отличия в API и конфигурации.

    В целом, OpenSearch можно рассматривать как более открытую и community-driven альтернативу
    Elasticsearch, которая предлагает большинство тех же функций и возможностей, но с более
    гибкой лицензией и более открытым подходом к разработке и поддержке.

    Когда стоит выбирать OpenSearch вместо Elasticsearch:
    - Если вы ищете более открытую и community-driven платформу.
    - Если вы хотите избежать ограничений лицензии Elastic.
    - Если вы хотите использовать более гибкую и настраиваемую платформу.
    - Если вы хотите поддержать более открытую и community-driven экосистему.
    Когда стоит выбирать Elasticsearch вместо OpenSearch:
    - Если вы уже используете Elasticsearch и не хотите мигрировать на новую платформу.
    - Если вы хотите использовать более коммерческую и поддерживаемую платформу.
    - Если вы хотите использовать более широкий спектр инструментов и приложений,
    которые работают с Elasticsearch.
```

## <a id="Реляционные-СУБД">Реляционные СУБД</a>

```txt
1 - Объекты БД: таблица, индекс, view, первичный ключ, триггер.
2 - Основы SQL.
3 - Транзакции.
4 - Хранимые процедуры.
```

### Notice-4

```txt
1 - Что такое схема в СУБД?

->  Схема в СУБД - это описание структуры базы данных, включающее определение таблиц,
    полей, связей между ними и других объектов базы данных.

    - Таблиц (например, "Клиенты", "Заказы", "Товары")
    - Поля (например, "Имя", "Адрес", "Дата рождения" в таблице "Клиенты")
    - Типов данных для каждого поля (например, "Имя" - строка, "Дата рождения" - дата)
    - Связей между таблицами (например, таблица "Заказы" связана с таблицей "Клиенты" по полю
    "Клиент_ID")
    - Индексов и ключей (например, первичный ключ "Клиент_ID" в таблице "Клиенты")
    - Других объектов базы данных (например, представлений, хранимых процедур)

    Например, схема базы данных для интернет-магазина может выглядеть так:
    Таблица "Клиенты":
    - Имя (строка)
    - Адрес (строка)
    - Дата рождения (дата)
    - Клиент_ID (первичный ключ)
    Таблица "Заказы":
    - Заказ_ID (первичный ключ)
    - Клиент_ID (внешний ключ, ссылка на таблицу "Клиенты")
    - Дата заказа (дата)
    - Сумма (число)
    Таблица "Товары":
    - Товар_ID (первичный ключ)
    - Название (строка)
    - Цена (число)

    Схема базы данных определяет структуру данных и обеспечивает целостность и согласованность
    данных.
```

```txt
2 - Что такое индекс в РСУБД?

->  Индекс в РСУБД (Реляционной Системе Управления Базами Данных) - это структура данных,
    которая позволяет быстро находить и извлекать данные из таблицы базы данных. Индекс
    создается на одном или нескольких полях таблицы и содержит ссылки на соответствующие
    записи в таблице.

    Индекс работает аналогично индексу в книге: он позволяет быстро найти нужную страницу
    (запись) без необходимости просматривать всю книгу (таблицу).

    Индекс может быть:
    - Уникальным (unique): гарантирует, что значения индексированного поля уникальны
    - Неуникальным (non-unique): позволяет дублировать значения индексированного поля
    - Композитным (composite): создается на нескольких полях таблицы
    Индекс используется для:
    - Ускорения поиска и извлечения данных
    - Улучшения производительности запросов
    - Обеспечения уникальности данных
    Например, если в таблице "Клиенты" создать индекс на поле "Имя", база данных сможет
    быстро найти все записи, соответствующие конкретному имени, без необходимости
    просматривать всю таблицу.

    SELECT * FROM Клиенты WHERE Имя = 'Иванов Иван'
    CREATE INDEX idx_имя ON Клиенты (Имя)
```

```txt
3 - Что такое view в РСУБД?

->  View (представление) в РСУБД (Реляционной Системе Управления Базами Данных) - это
    виртуальная таблица, которая основана на одном или нескольких физических таблицах базы
    данных. Представление не хранит данные самостоятельно, а вместо этого предоставляет
    доступ к данным из физических таблиц.

    Представление можно рассматривать как сохраненный запрос, который можно использовать как
    обычную таблицу. Представление может включать в себя сложные запросы, включающие
    соединения таблиц, группировку, сортировку и другие операции.

    Представление имеет следующие характеристики:
    - Не хранит данные самостоятельно
    - Основано на одном или нескольких физических таблицах
    - Предоставляет доступ к данным из физических таблиц
    - Может включать в себя сложные запросы
    - Может быть использовано как обычная таблица

    Представление используется для:
    - Упрощения доступа к данным
    - Обеспечения безопасности данных
    - Создания виртуальных таблиц для конкретных задач
    - Улучшения производительности запросов

    Например, рассмотрим таблицу "Клиенты" с полями "Имя", "Адрес" и "Дата рождения", и
    таблицу "Заказы" с полями "Заказ_ID", "Клиент_ID" и "Дата заказа". Мы можем создать
    представление, которое включает в себя информацию о клиентах и их заказах:

    CREATE VIEW Клиенты_с_заказами AS
    SELECT Клиенты.Имя, Клиенты.Адрес, Заказы.Дата_заказа
    FROM Клиенты
    JOIN Заказы ON Клиенты.Клиент_ID = Заказы.Клиент_ID

    Это представление будет включать в себя информацию о клиентах и их заказах, и мы можем
    использовать его как обычную таблицу:
    SELECT * FROM Клиенты_с_заказами
    Представление будет автоматически обновляться, когда данные в физических таблицах
    изменятся.
```

```txt
4 - Что такое первичный ключ в РСУБД?

->  Первичный ключ (Primary Key) в РСУБД (Реляционной Системе Управления Базами Данных) - это
    уникальный идентификатор записи в таблице, который используется для однозначного
    определения каждой записи.

    Первичный ключ имеет следующие характеристики:
    - Уникален для каждой записи в таблице
    - Не может быть пустым или null
    - Не может быть изменен после создания записи
    - Используется для однозначного определения каждой записи

    Первичный ключ используется для:
    - Обеспечения уникальности записей в таблице
    - Установления связи между таблицами
    - Ускорения поиска и извлечения данных
    - Обеспечения целостности данных

    Например, рассмотрим таблицу "Клиенты" с полями "Клиент_ID", "Имя", "Адрес" и
    "Дата рождения". Мы можем определить поле "Клиент_ID" как первичный ключ:
    CREATE TABLE Клиенты (
    Клиент_ID INT PRIMARY KEY,
    Имя VARCHAR(50),
    Адрес VARCHAR(100),
    Дата_рождения DATE
    )
    В этом случае поле "Клиент_ID" будет уникальным для каждой записи в таблице, и мы можем
    использовать его для однозначного определения каждой записи
```

```txt
5 - Что такое транзакция в РСУБД?

->  Транзакция (Transaction) в РСУБД (Реляционной Системе Управления Базами Данных) - это
    последовательность операций, которые выполняются как единое целое, чтобы обеспечить
    целостность и согласованность данных.

    Транзакция имеет следующие характеристики:
    - Атомарность: транзакция выполняется как единое целое, либо полностью, либо не выполняется
    вовсе.
    - Согласованность: транзакция сохраняет целостность данных, т.е. данные остаются в
    согласованном состоянии после выполнения транзакции.
    - Изоляция: транзакция выполняется независимо от других транзакций, т.е. изменения,
    внесенные одной транзакцией, не видны другим транзакциям до тех пор, пока первая
    транзакция не будет завершена.
    - Долговечность: результаты транзакции сохраняются после ее завершения.

    Транзакция используется для:
    - Обеспечения целостности данных
    - Предотвращения потери данных
    - Обеспечения согласованности данных
    - Улучшения производительности

    Например, рассмотрим сценарий, в котором пользователь хочет перевести деньги с одного
    счета на другой. Это можно сделать с помощью транзакции, которая включает в себя
    следующие операции:

    1-Снятие денег со счета отправителя
    2-Перевод денег на счет получателя
    3-Обновление баланса счетов
    Если одна из этих операций не выполнится, вся транзакция будет отменена, и данные
    будут восстановлены в исходное состояние. Это обеспечивает целостность и согласованность
    данных.

    В РСУБД транзакции можно управлять с помощью команд:
    - BEGIN TRANSACTION: начинает транзакцию
    - COMMIT: завершает транзакцию и сохраняет изменения
    - ROLLBACK: отменяет транзакцию и восстанавливает данные в исходное состояние

    BEGIN TRANSACTION;
    UPDATE Счета SET Баланс = Баланс - 100 WHERE ID = 1;
    UPDATE Счета SET Баланс = Баланс + 100 WHERE ID = 2;
    COMMIT;
```

```txt
6 - Как вывести данные определенного столбца в отсортированном по возрастанию виде (SQL)?

->  SELECT столбец FROM таблица ORDER BY столбец ASC;

    - SELECT столбец - выбирает данные из столбца, который нужно вывести
    - FROM таблица - указывает таблицу, из которой нужно вывести данные
    - ORDER BY столбец - сортирует данные по столбцу
    - ASC - указывает, что данные нужно сортировать по возрастанию (ascending)
    - DESC - указывает, что данные нужно сортировать по убыванию (descending)
```

### Intern-4

```txt
1 - Почему нельзя проиндексировать все столбцы во всех таблицах в РСУБД для
    максимального ускорения поиска?

->  Хотя индексация столбцов может ускорить поиск в таблицах, проиндексировать все столбцы
    во всех таблицах не рекомендуется по нескольким причинам:
    - Увеличение размера базы данных: Индексация столбцов требует дополнительного места на
    диске для хранения индексов. Если проиндексировать все столбцы, размер базы данных может
    существенно увеличиться, что может привести к проблемам с хранением и управлением базой
    данных.
    - Увеличение времени обновления: Когда данные в таблице обновляются, индекс также должен
    быть обновлен. Если проиндексировать все столбцы, время обновления может увеличиться, что
    может привести к проблемам с производительностью.
    - Увеличение времени создания индексов: Создание индексов может занять много времени,
    особенно для больших таблиц. Если проиндексировать все столбцы, время создания индексов
    может увеличиться, что может привести к проблемам с доступностью базы данных.
    - Уменьшение эффективности запросов: Если проиндексировать все столбцы, запросы могут
    стать менее эффективными, поскольку база данных будет тратить больше времени на поиск и
    обновление индексов.
    - Увеличение сложности управления базой данных: Если проиндексировать все столбцы,
    управление базой данных может стать более сложным, поскольку необходимо будет следить
    за индексами и обновлять их регулярно.

    Вместо этого, рекомендуется проиндексировать только те столбцы, которые используются в
    часто выполняемых запросах, и которые имеют высокую кардинальность (т.е. имеют много
    уникальных значений). Это позволит оптимизировать производительность базы данных и
    уменьшить размер базы данных.

    Например, если у нас есть таблица "Клиенты" с столбцами "Имя", "Адрес" и "Дата рождения",
    и мы часто выполняем запросы по имени клиента, мы можем проиндексировать только столбец
    "Имя". Это позволит ускорить поиск клиентов по имени, но не увеличит размер базы данных
    и не уменьшит эффективность запросов.
```

```txt
2 - Что такое составной первичный ключ в РСУБД?

->  Составной первичный ключ (Composite Primary Key) в РСУБД - это первичный ключ, который
    состоит из двух или более столбцов таблицы. Этот ключ используется для однозначного
    определения каждой записи в таблице.

    Составной первичный ключ имеет следующие характеристики:
    - Состоит из двух или более столбцов таблицы
    - Каждый столбец, входящий в составной ключ, должен быть уникальным
    - Составной ключ должен быть уникальным для каждой записи в таблице
    - Составной ключ не может быть пустым или null
    - Составной первичный ключ используется в тех случаях, когда один столбец не может
    однозначно определить запись в таблице.

    CREATE TABLE Заказы (
    Заказ_ID INT,
    Клиент_ID INT,
    Дата_заказа DATE,
    PRIMARY KEY (Заказ_ID, Клиент_ID)
    )
    В этом случае первичный ключ состоит из двух полей: "Заказ_ID" и "Клиент_ID".
    Это означает, что каждая запись в таблице будет уникально определяться комбинацией
    значений этих двух полей.

    Составной первичный ключ имеет следующие преимущества:
    - Увеличивает уникальность данных
    - Улучшает производительность запросов
    - Упрощает управление данными
    Однако составной первичный ключ также имеет некоторые недостатки:
    - Увеличивает сложность управления данными
    - Требует больше места на диске для хранения ключа
    - Может привести к проблемам с производительностью, если ключ состоит из слишком
    многих столбцов.
```

```txt
3 - Что такое хранимая процедура? В чем преимущества и недостатки использования
    хранимых процедур?

->  Хранимая процедура (Stored Procedure) - это набор SQL-команд, которые хранятся в базе
    данных и могут быть вызваны по имени. Хранимые процедуры позволяют выполнять сложные
    операции с данными, такие как выборка, вставка, обновление и удаление данных, а также
    выполнять сложные вычисления и проверки.

    Преимущества использования хранимых процедур:
    - Увеличенная производительность: Хранимые процедуры могут быть оптимизированы для 
    выполнения сложных операций с данными, что может увеличить производительность базы данных.
    - Уменьшение нагрузки на сервер: Хранимые процедуры могут быть вызваны по имени,
    что уменьшает нагрузку на сервер, поскольку не требуется передавать данных между
    клиентом и сервером.
    - Улучшение безопасности: Хранимые процедуры могут быть использованы для ограничения
    доступа к данным, поскольку они могут быть вызваны только с определенных прав доступа.
    - Упрощение управления данными: Хранимые процедуры могут быть использованы для упрощения
    управления данными, поскольку они могут быть вызваны по имени и выполнять сложные операции
    с данными.
    - Возможность повторного использования: Хранимые процедуры могут быть повторно использованы
    в различных приложениях, что уменьшает количество кода, который необходимо написать.

    Недостатки использования хранимых процедур:
    - Сложность разработки: Хранимые процедуры могут быть сложными для разработки, особенно
    если они выполняют сложные операции с данными.
    - Трудность отладки: Хранимые процедуры могут быть трудными для отладки, поскольку они
    выполняются на сервере и могут быть вызваны по имени.
    - Неподдержка стандартов: Хранимые процедуры могут не поддерживать стандарты SQL, что
    может привести к проблемам с совместимостью между различными базами данных.
    - Увеличение размера базы данных: Хранимые процедуры могут увеличить размер базы данных,
    поскольку они хранятся в базе данных.
    - Требование обновления: Хранимые процедуры могут требовать обновления, если они
    выполняют сложные операции с данными, что может привести к проблемам с совместимостью
    между различными версиями базы данных.

    CREATE PROCEDURE GetCustomerInfo
    @CustomerID INT
    AS
    BEGIN
    SELECT * FROM Customers WHERE CustomerID = @CustomerID
    END

    Эта хранимая процедура принимает один параметр @CustomerID и возвращает
    информацию о клиенте с указанным идентификатором.

    Чтобы вызвать эту хранимую процедуру, можно использовать следующий код:
    EXEC GetCustomerInfo @CustomerID = 123

    Эта команда вызовет хранимую процедуру GetCustomerInfo и передаст ей параметр
    @CustomerID со значением 123. Хранимая процедура затем выполнит запрос к таблице
    Customers и вернет информацию о клиенте с идентификатором 123
```

```txt
4 - Что такое Join в SQL? Какие виды Join бывают?

->  Join в SQL - это операция, которая позволяет объединить данные из двух или более таблиц
    в одну таблицу. Join позволяет связать данные из разных таблиц по общему столбцу или
    набору столбцов.

    INNER JOIN: Этот тип Join возвращает только те записи, которые имеют
    соответствующие значения в обоих таблицах.
    SELECT * FROM Customers
    INNER JOIN Orders ON Customers.CustomerID = Orders.CustomerID
    Этот запрос возвращает все записи из таблицы Customers и соответствующие записи из
    таблицы Orders, где CustomerID совпадает.

    LEFT JOIN: Этот тип Join возвращает все записи из левой таблицы и соответствующие
    записи из правой таблицы. Если в правой таблице нет соответствующих записей, то в
    результате будет NULL.
    SELECT * FROM Customers
    LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID
    Этот запрос возвращает все записи из таблицы Customers и соответствующие записи из
    таблицы Orders, где CustomerID совпадает. Если в таблице Orders нет соответствующих
    записей, то в результате будет NULL.

    RIGHT JOIN: Этот тип Join возвращает все записи из правой таблицы и соответствующие
    записи из левой таблицы. Если в левой таблице нет соответствующих записей, то в
    результате будет NULL.
    SELECT * FROM Customers
    RIGHT JOIN Orders ON Customers.CustomerID = Orders.CustomerID
    Этот запрос возвращает все записи из таблицы Orders и соответствующие записи из таблицы
    Customers, где CustomerID совпадает. Если в таблице Customers нет соответствующих записей,
    то в результате будет NULL.

    FULL OUTER JOIN: Этот тип Join возвращает все записи из обеих таблиц, даже если нет
    соответствующих записей в другой таблице.
    SELECT * FROM Customers
    FULL OUTER JOIN Orders ON Customers.CustomerID = Orders.CustomerID
    Этот запрос возвращает все записи из обеих таблиц, даже если нет соответствующих
    записей в другой таблице.

    CROSS JOIN: Этот тип Join возвращает все возможные комбинации записей из обеих таблиц.
    SELECT * FROM Customers
    CROSS JOIN Orders
    Этот запрос возвращает все возможные комбинации записей из обеих таблиц.
```

### Advanced-4

```txt
1 - Какие типы индексов бывают?

->  CREATE TABLE customers (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    email VARCHAR(100),
    is_active BIT
    );
    
    - Б-дерево индекс (B-tree index): Этот тип индекса используется для хранения данных в виде
    дерева, где каждый узел содержит ключ и указатель на следующий узел. Б-дерево индекс
    позволяет быстро находить данные по ключу.
        CREATE INDEX idx_name ON customers (name);

    - Хеш-индекс (Hash index): Этот тип индекса используется для хранения данных в виде
    хеш-таблицы, где каждый ключ соответствует определенной позиции в таблице. Хеш-индекс
    позволяет быстро находить данные по ключу.
        CREATE INDEX idx_email ON customers (email) USING HASH;

    - Битовый индекс (Bitmap index): Этот тип индекса используется для хранения данных в
    виде битовой карты, где каждый бит соответствует определенной позиции в таблице. Битовый
    индекс позволяет быстро находить данные по ключу.
        CREATE INDEX idx_is_active ON customers (is_active) USING BITMAP;

    - Глобальный индекс (Global index): Этот тип индекса используется для хранения данных в
    виде глобальной таблицы, где каждый ключ соответствует определенной позиции в таблице.
    Глобальный индекс позволяет быстро находить данные по ключу.
        CREATE INDEX idx_name ON customers (name) GLOBAL;

    - Локальный индекс (Local index): Этот тип индекса используется для хранения данных в
    виде локальной таблицы, где каждый ключ соответствует определенной позиции в таблице.
    Локальный индекс позволяет быстро находить данные по ключу.
        CREATE INDEX idx_name ON customers (name) LOCAL;

    - Композитный индекс (Composite index): Этот тип индекса используется для хранения данных
    в виде композитной таблицы, где каждый ключ состоит из нескольких полей. Композитный
    индекс позволяет быстро находить данные по ключу.
        CREATE INDEX idx_name_email ON customers (name, email);

    - Уникальный индекс (Unique index): Этот тип индекса используется для хранения данных в
    виде уникальной таблицы, где каждый ключ соответствует определенной позиции в таблице.
    Уникальный индекс позволяет быстро находить данные по ключу.
        CREATE UNIQUE INDEX idx_email ON customers (email);

    - Неуникальный индекс (Non-unique index): Этот тип индекса используется для хранения
    данных в виде неуникальной таблицы, где каждый ключ может соответствовать нескольким
    позициям в таблице. Неуникальный индекс позволяет быстро находить данные по ключу.
        CREATE INDEX idx_name ON customers (name);
```

```txt
2 - Что такое CAP-теорема?

->  CAP-теорема (CAP theorem) - это теорема, которая описывает фундаментальные ограничения,
    которые существуют в распределенных системах, особенно в базах данных и системах
    хранения данных.

    CAP-теорема утверждает, что в любой распределенной системе можно обеспечить не более
    двух из следующих трех свойств:

    - Согласованность (Consistency): Все узлы системы должны иметь одинаковое представление о
    состоянии системы.
    - Доступность (Availability): Система должна быть доступна для чтения и записи в любой
    момент времени.
    - Раздельность (Partition tolerance): Система должна быть способна работать даже в случае
    разделения сети или потери связи между узлами.

    CAP-теорема утверждает, что невозможно обеспечить все три свойства одновременно. Если
    система обеспечивает согласованность и доступность, она не может обеспечить раздельность.
    Если система обеспечивает доступность и раздельность, она не может обеспечить
    согласованность.

    CAP-теорема имеет важные последствия для проектирования распределенных систем, особенно
    баз данных и систем хранения данных. Она требует от разработчиков систем сделать выбор
    между согласованностью, доступностью и раздельностью, в зависимости от требований системы.

    Например, если система требует высокой доступности и раздельности, она может использовать
    механизмы репликации данных, которые обеспечивают доступность данных даже в случае
    разделения сети. Однако, это может привести к проблемам с согласованностью данных,
    поскольку данные могут быть реплицированы в разных узлах системы.

    CAP-теорема была впервые сформулирована в 2000 году Эриком Брюером и его коллегами из
    Массачусетского технологического института. Она стала фундаментальной концепцией в области
    распределенных систем и баз данных.

    Примеры систем, которые демонстрируют CAP-теорему:
    - Apache Cassandra: обеспечивает доступность и раздельность, но не обеспечивает
    согласованность.
    - MySQL: обеспечивает согласованность и доступность, но не обеспечивает раздельность.
```

```txt
3 - Будет ли SQL запрос написанный для РСУБД Oracle корректно работать в PostgreSQL? Почему?

->  SQL запрос, написанный для РСУБД Oracle, может не работать корректно в PostgreSQL,
    поскольку эти две системы управления базами данных имеют некоторые различия в синтаксисе
    и функциональности.

    Некоторые из основных различий между Oracle и PostgreSQL включают:
    - Синтаксис SQL: Oracle и PostgreSQL имеют некоторые различия в синтаксисе SQL, особенно
    в части использования ключевых слов и функций.
    - Типы данных: Oracle и PostgreSQL имеют разные типы данных, особенно в части даты и
    времени.
    - Функции и процедуры: Oracle и PostgreSQL имеют разные функции и процедуры, особенно в
    части работы с данными.
    - Параметры соединения: Oracle и PostgreSQL имеют разные параметры соединения, особенно
    в части аутентификации и авторизации.

    Некоторые из наиболее распространенных проблем, которые могут возникнуть при переносе SQL
    запроса из Oracle в PostgreSQL, включают:
    - Использование ключевых слов: Oracle и PostgreSQL имеют разные ключевые слова, которые
    могут быть использованы в SQL запросах.
    - Использование функций: Oracle и PostgreSQL имеют разные функции, которые могут быть
    использованы в SQL запросах.
    - Использование типов данных: Oracle и PostgreSQL имеют разные типы данных, которые могут
    быть использованы в SQL запросах.
    - Использование параметров соединения: Oracle и PostgreSQL имеют разные параметры
    соединения, которые могут быть использованы в SQL запросах.

    Чтобы SQL запрос, написанный для Oracle, работал корректно в PostgreSQL, необходимо
    выполнить следующие шаги:
    - Переписать SQL запрос: Перепишите SQL запрос, используя синтаксис и функции
    PostgreSQL.
    - Использовать типы данных PostgreSQL: Используйте типы данных PostgreSQL вместо
    типов данных Oracle.
    - Использовать функции и процедуры PostgreSQL: Используйте функции и процедуры
    PostgreSQL вместо функций и процедур Oracle.
    - Использовать параметры соединения PostgreSQL: Используйте параметры соединения
    PostgreSQL вместо параметров соединения Oracle.

    Например, если у вас есть SQL запрос, написанный для Oracle:
    SELECT * FROM таблица WHERE дата >= SYSDATE - 30;

    Чтобы этот запрос работал корректно в PostgreSQL, необходимо переписать его следующим
    образом:
    SELECT * FROM таблица WHERE дата >= CURRENT_DATE - INTERVAL '30 day';

    В этом примере мы используем функцию CURRENT_DATE вместо SYSDATE, и
    тип данных INTERVAL вместо NUMBER.
```

```txt
4 - Какие бывают уровни изоляции транзакций?

->  В базах данных существует четыре уровня изоляции транзакций, которые определяют, как
    транзакции взаимодействуют друг с другом:
    - Читаемые неподтвержденные данные (Read Uncommitted): Этот уровень изоляции позволяет
    транзакциям читать данные, которые еще не были подтверждены другими транзакциями. Это
    означает, что транзакция может прочитать данные, которые могут быть отменены или изменены
    другими транзакциями.
    - Читаемые подтвержденные данные (Read Committed): Этот уровень изоляции позволяет
    транзакциям читать только подтвержденные данные. Это означает, что транзакция может
    прочитать только данные, которые были подтверждены другими транзакциями.
    - Повторяемое чтение (Repeatable Read): Этот уровень изоляции позволяет транзакциям
    читать данные, которые были прочитаны ранее в транзакции, и гарантирует, что данные
    не будут изменены другими транзакциями до подтверждения текущей транзакции.
    - Серийное изоляция (Serializable): Этот уровень изоляции является самым высоким уровнем
    изоляции и гарантирует, что транзакции будут выполняться последовательно, как если бы они
    были единственной транзакцией в системе.

    Каждый уровень изоляции имеет свои преимущества и недостатки, и выбор уровня изоляции 
    зависит от конкретных требований приложения.
    Например, если приложение требует высокой производительности и может терпеть некоторые
    несоответствия в данных, то уровень изоляции "Читаемые неподтвержденные данные" может быть
    подходящим выбором. Однако, если приложение требует высокой степени согласованности данных,
    то уровень изоляции "Серийное изоляция" может быть более подходящим выбором.

    В PostgreSQL, уровень изоляции можно задать с помощью команды
    SET TRANSACTION ISOLATION LEVEL, например:
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

    -- Создаем таблицу
    CREATE TABLE таблица (столбец1 INT, столбец2 INT);
    -- Начинаем транзакцию 1
    BEGIN TRANSACTION;
    INSERT INTO таблица (столбец1, столбец2) VALUES (1, 2);
    -- Начинаем транзакцию 2
    BEGIN TRANSACTION;
    SELECT * FROM таблица WHERE столбец1 = 1;
    -- Транзакция 2 видит данные, которые еще не были подтверждены транзакцией 1
    -- Результат: (1, 2)
    -- Транзакция 1 отменяется
        ROLLBACK;
    -- Транзакция 2 все еще видит данные, которые были отменены
    -- Результат: (1, 2)
```

## <a id="Администрирование-СУБД">Администрирование СУБД</a>

```txt
1 - Бэкапирование СУБД.
2 - Понятие репликации, виды репликации.
3 - Понятие шардирования, виды шардирования
```

### Notice-5

```txt
1 - Какие бывают типы бэкапов в СУБД?

->  В СУБД бывают следующие типы бэкапов:

    - Полный бэкап (Full backup) - полная копия базы данных. Создаётся копия всех данных и
    структуры базы данных. Пример: ежедневный полный бэкап базы данных в 23:00.

    - Дифференциальный бэкап (Differential backup) - копия изменений с момента последнего
    полного бэкапа. Создаётся копия только тех данных, которые были изменены с момента
    последнего полного бэкапа. Пример: ежедневный дифференциальный бэкап базы данных в 23:00,
    если последний полный бэкап был сделан вчера в 23:00.

    - Инкрементальный бэкап (Incremental backup) - копия изменений с момента последнего бэкапа
    (полного или дифференциального). Создаётся копия только тех данных, которые были изменены
    с момента последнего бэкапа. Пример: ежечасный инкрементальный бэкап базы данных, если
    последний бэкап был сделан час назад.

    - Логический бэкап (Logical backup) - копия структуры и данных базы данных в виде
    SQL-скриптов. Создаётся копия базы данных в виде текстового файла, содержащего SQL-команды
    для воссоздания базы данных. Пример: экспорт базы данных в виде SQL-скрипта для переноса
    на другую платформу.

    - Физический бэкап (Physical backup) - копия файлов базы данных. Создаётся копия файлов,
    в которых хранится база данных. Пример: копирование файлов базы данных на другое
    устройство для хранения.

    - Полный бэкап (Full backup) - полная копия базы данных.
    - Дифференциальный бэкап (Differential backup) - копия изменений с момента последнего
      полного бэкапа.
    - Инкрементальный бэкап (Incremental backup) - копия изменений с момента последнего бэкапа
    (полного или дифференциального).
    - Логический бэкап (Logical backup) - копия структуры и данных базы данных в виде
      SQL-скриптов.
    - Физический бэкап (Physical backup) - копия файлов базы данных.

```

```txt
2 - Что такое репликация?

->  Репликация - это процесс создания и поддержания копий базы данных в реальном времени или
    с задержкой на нескольких серверах или узлах. Это позволяет обеспечить высокую доступность
    и отказоустойчивость базы данных, а также улучшить производительность за счет
    распределения нагрузки между несколькими серверами.

    Репликация позволяет решить следующие задачи:
    - Обеспечение высокой доступности базы данных: если один сервер становится недоступным,
    данные можно получить с другого сервера.
    - Улучшение производительности: распределение нагрузки между несколькими серверами
    позволяет увеличить скорость обработки запросов.
    - Обеспечение отказоустойчивости базы данных: если один сервер выходит из строя, данные
    можно восстановить с другого сервера.
    - Создание резервных копий базы данных: репликация позволяет создать копию базы данных
    на другом сервере, что может быть полезно для восстановления данных в случае сбоя.
    - Обеспечение географической доступности базы данных: репликация позволяет создать копию
    базы данных в разных географических местах, что может быть полезно для пользователей,
    находящихся в разных частях мира.

    Репликация может быть использована в различных сценариях, таких как:
    - Веб-приложения: репликация может быть использована для обеспечения высокой
    доступности и производительности веб-приложений.
    - Бизнес-приложения: репликация может быть использована для обеспечения отказоустойчивости
    и высокой доступности бизнес-приложений.
    - Мобильные приложения: репликация может быть использована для обеспечения высокой
    доступности и производительности мобильных приложений.
    - Игровые приложения: репликация может быть использована для обеспечения высокой
    доступности и производительности игровых приложений
```

### Intern-5

```txt
1 - Какие бывают типы репликации?

->  - Синхронная репликация: данные записываются на все серверы одновременно, что гарантирует,
    что все серверы имеют одинаковую версию данных. Это обеспечивает высокую доступность и
    целостность данных, но может привести к увеличению времени ответа и снижению
    производительности.

    - Асинхронная репликация: данные записываются на основной сервер, а затем копируются на
    другие серверы с задержкой, что позволяет уменьшить нагрузку на основной сервер. Это
    обеспечивает высокую производительность, но может привести к несоответствию данных между
    серверами.

    - Полусинхронная репликация: данные записываются на основной сервер, а затем копируются
    на другие серверы с задержкой, но с гарантией, что данные будут записаны на все серверы
    в конечном итоге. Это обеспечивает баланс между производительностью и доступностью.

    - Мульти-мастер репликация: несколько серверов могут принимать записи и реплицировать
    данные между собой, что позволяет увеличить производительность и доступность. Это
    обеспечивает высокую доступность и производительность, но может привести к сложности
    управления и конфликтам данных.

    - Ленточная репликация: данные реплицируются через несколько серверов, образуя цепочку,
    что позволяет уменьшить нагрузку на основной сервер. Это обеспечивает высокую доступность
    и производительность, но может привести к увеличению времени ответа.

    - Шардированная репликация: данные разбиваются на несколько фрагментов, которые
    реплицируются на разных серверах, что позволяет увеличить производительность и доступность.
    Это обеспечивает высокую доступность и производительность, но может привести к сложности
    управления и конфликтам данных.

    - Гибридная репликация: комбинация различных типов репликации, таких как синхронная и
    асинхронная репликация, что позволяет оптимизировать производительность и доступность.
    Это обеспечивает высокую доступность и производительность, но может привести к сложности
    управления и конфликтам данных.

    - Репликация с использованием журнала: данные записываются в журнал, который затем
    реплицируется на другие серверы, что позволяет уменьшить нагрузку на основной сервер.
    Это обеспечивает высокую доступность и производительность, но может привести к увеличению
    времени ответа.

    - Репликация с использованием снимков: данные реплицируются с использованием снимков, что
    позволяет уменьшить нагрузку на основной сервер. Это обеспечивает высокую доступность и
    производительность, но может привести к увеличению времени ответа.

    Типы репликации баз данных:
    1 - Мастер-реплика (Master-Slave): Основная база данных (мастер) обновляется, а копии
    (реплики) синхронизируются с мастером.
    2 - Мастер-мастер (Master-Master): Все базы данных являются мастерами и могут обновляться
    независимо.
    3 - Мульти-мастер (Multi-Master): Комбинация мастер-реплика и мастер-мастер репликации.
    4 - Синхронная репликация: Обновления синхронизируются между базами данных в режиме
    реального времени.
    5 - Асинхронная репликация: Обновления синхронизируются между базами данных с задержкой.

    Методы репликации баз данных:
    1 - Логическая репликация: Репликация баз данных на уровне логических операций
    (например, INSERT, UPDATE, DELETE).
    2 - Физическая репликация: Репликация баз данных на уровне физических блоков данных.
    3 - Снимок репликация: Репликация баз данных путем создания снимков данных в определенные
    моменты времени.
    
    Примеры репликации баз данных:
    1 - MySQL: Использует мастер-реплика репликацию для обеспечения высокой доступности и
    масштабируемости.
    2 - PostgreSQL: Использует мастер-реплика и мастер-мастер репликацию для обеспечения
    высокой доступности и масштабируемости.
```

### Advanced-5

```txt
1 - Что такое шардирование?

->  Шардирование (sharding) - это метод разделения больших объемов данных на более мелкие
    фрагменты, называемые шардами (shards), которые затем распределяются между несколькими
    серверами или узлами. Это позволяет увеличить производительность и доступность системы,
    поскольку данные можно обрабатывать параллельно на нескольких серверах.

    Шардирование часто используется в больших базах данных, где объем данных слишком
    велик для хранения на одном сервере. Шардирование позволяет разделить данные на более
    мелкие фрагменты, которые можно хранить на нескольких серверах, что упрощает управление
    данными и увеличивает производительность.

    Шардирование может быть осуществлено по различным критериям, таким как:
    - Географическое шардирование: данные разделены по географическому принципу,
    например, по странам или регионам.
    - Функциональное шардирование: данные разделены по функциональному принципу,
    например, по типу данных или по приложению.
    - Хэш-шардирование: данные разделены по хэш-функции, которая распределяет данные
    по серверам на основе их хэш-значения.

    Шардирование имеет следующие преимущества:
    - Увеличенная производительность: данные можно обрабатывать параллельно на нескольких
    серверах, что увеличивает производительность.
    - Увеличенная доступность: данные можно хранить на нескольких серверах, что увеличивает
    доступность.
    - Уменьшение нагрузки: данные можно разделить на более мелкие фрагменты, что уменьшает
    нагрузку на каждый сервер.
    Однако шардирование также имеет некоторые недостатки, такие как:
    - Сложность управления: шардирование требует сложного управления данными и серверами.
    - Конфликты данных: данные могут конфликтовать между собой, если они не синхронизированы
    правильно.
    - Увеличенная сложность: шардирование может увеличить сложность системы, что может привести
    к ошибкам и проблемам.
```

```txt
2 - Какие бывают типы шардирования?

->  - Горизонтальное шардирование: данные разделены по горизонтали, т.е. по строкам таблицы.
    Каждый шард содержит подмножество строк таблицы. Это позволяет увеличить производительность
    и доступность системы, поскольку данные можно обрабатывать параллельно на нескольких
    серверах.

    - Вертикальное шардирование: данные разделены по вертикали, т.е. по столбцам таблицы.

    Каждый шард содержит подмножество столбцов таблицы. Это позволяет уменьшить размер таблицы
    и увеличить производительность, поскольку данные можно обрабатывать более эффективно.
    - Гибридное шардирование: данные разделены как по горизонтали, так и по вертикали. Это
    позволяет комбинировать преимущества горизонтального и вертикального шардирования.

    - Шардирование по ключу: данные разделены по ключу, т.е. по уникальному идентификатору
    записи. Это позволяет быстро находить и обрабатывать данные, поскольку ключи можно
    использовать для быстрого доступа к данным.

    - Шардирование по диапазону: данные разделены по диапазону, т.е. по определённому диапазону
    значений ключа. Это позволяет эффективно обрабатывать данные, поскольку диапазоны можно
    использовать для быстрого доступа к данным.

    - Шардирование по хэшу: данные разделены по хэшу, т.е. по хэш-функции, которая распределяет
    данные по серверам. Это позволяет быстро обрабатывать данные, поскольку хэш-функция может
    быть использована для быстрого доступа к данным.

    - Динамическое шардирование: данные разделены динамически, т.е. в зависимости от нагрузки и
    других факторов. Это позволяет адаптироваться к меняющимся условиям и обеспечить высокую
    производительность и доступность системы.

    - Статическое шардирование: данные разделены статически, т.е. в зависимости от заранее
    определённых критериев. Это позволяет обеспечить высокую производительность и доступность
    системы, поскольку данные можно обрабатывать параллельно на нескольких серверах.

    - Автоматическое шардирование: данные разделены автоматически, т.е. без участия
    администратора. Это позволяет упростить процесс шардирования и обеспечить высокую
    производительность и доступность системы.

    - Ручное шардирование: данные разделены вручную, т.е. администратором. Это позволяет
    обеспечить высокую производительность и доступность системы, поскольку данные можно
    обрабатывать параллельно на нескольких серверах.
```

```txt
3 - Как обеспечить отказоустойчивость СУБД

->  Обеспечение отказоустойчивости СУБД (Системы Управления Базами Данных) является важнейшим
    аспектом проектирования и эксплуатации баз данных. Отказоустойчивость СУБД обеспечивает
    высокую доступность и надежность базы данных, даже в случае сбоя или отказа отдельных
    компонентов системы.

    - Репликация данных: репликация данных является одним из наиболее эффективных способов
    обеспечения отказоустойчивости СУБД. Репликация данных предполагает создание копий данных
    на нескольких серверах, что позволяет обеспечить доступность данных даже в случае сбоя или
    отказа отдельного сервера.

    - Кластеризация: кластеризация предполагает объединение нескольких серверов в кластер,
    который работает как единая система. Кластеризация позволяет обеспечить отказоустойчивость
    СУБД, поскольку если один сервер в кластере выходит из строя, другие серверы могут
    продолжать работать.

    - Распределение данных: распределение данных предполагает разделение данных на несколько
    серверов, что позволяет обеспечить отказоустойчивость СУБД. Распределение данных также
    позволяет увеличить производительность системы, поскольку данные можно обрабатывать
    параллельно на нескольких серверах.

    - Создание резервных копий: создание резервных копий является важнейшим аспектом
    обеспечения отказоустойчивости СУБД. Резервные копии позволяют восстановить данные в
    случае сбоя или отказа системы.

    - Использование RAID: RAID (Redundant Array of Independent Disks) является технологией,
    которая позволяет обеспечить отказоустойчивость хранения данных. RAID предполагает
    использование нескольких жестких дисков, которые работают вместе для обеспечения
    отказоустойчивости хранения данных.

    - Использование SAN: SAN (Storage Area Network) является технологией, которая позволяет
    обеспечить отказоустойчивость хранения данных. SAN предполагает использование отдельной
    сети для хранения данных, что позволяет обеспечить отказоустойчивость хранения данных.

    - Использование кластерных файловых систем: кластерные файловые системы являются
    технологией, которая позволяет обеспечить отказоустойчивость хранения данных. Кластерные
    файловые системы предполагают использование нескольких серверов для хранения данных, что
    позволяет обеспечить отказоустойчивость хранения данных.

    - Использование автоматизированных систем: автоматизированные системы являются
    технологией, которая позволяет обеспечить отказоустойчивость СУБД. Автоматизированные
    системы предполагают использование программного обеспечения для автоматизации процессов,
    что позволяет обеспечить отказоустойчивость СУБД.

    - Использование мониторинга: мониторинг является технологией, которая позволяет обеспечить
    отказоустойчивость СУБД. Мониторинг предполагает использование программного обеспечения
    для мониторинга системы, что позволяет обнаружить и исправить ошибки до того, как они
    приведут к сбою системы.

    - Использование тестирования: тестирование является технологией, которая позволяет
    обеспечить отказоустойчивость СУБД. Тестирование предполагает использование программного
    обеспечения для тестирования системы, что позволяет обнаружить и исправить ошибки до того,
    как они приведут к сбою системы.
```
